---
title: "`r knitr::current_input()`"
date: "`r paste('last updated', 
    format(lubridate::now(), ' %d %B %Y'))`"
output:   
  html_document:  
        code_folding: show
        toc: true 
        toc_depth: 2
        toc_float: true
  pdf_document:   
    latex_engine: xelatex  
    toc: true
    toc_depth:  2   
fontsize: 11pt   
geometry: margin=0.5in,top=0.25in   
TAGS:  data.table,purrr,structure,dput,normalize,starwars
---

PURPOSE:  non-joins (vs. `anti-join`)
NOTE:  Example taken from updating R packages, where .libPaths()[[2]] is read-only

TODO:
- setorder
- 
### Create toy example
installed:  

```{r}
library(data.table)
(dt = data.table(x=(LETTERS[1:4]),
           y= c(rep(1,4))
           ))
#   add 4 packages in 2
    (dt = rbind(dt, data.table(x = LETTERS[5:8],y= c(rep(2,4))) ))
#

(dt= rbind(dt, data.table(x=c("E","H"), y=c(1,1))))
dput(dt)
# structure(list(x = c("A", "B", "C", "D", "E", "F", "G", "H", 
# "E", "H"), y = c(1, 1, 1, 1, 2, 2, 2, 2, 1, 1)), row.names = c(NA, 
# -10L), class = c("data.table", "data.frame"), .internal.selfref = <pointer: 0x560cb46fd740>)
#     x y
#  1: A 1
#  2: B 1
#  3: C 1
#  4: D 1
#  5: E 2
#  6: F 2
#  7: G 2
#  8: H 2
#  9: E 1
# 10: H 1
```
```{r}

### Candidates  
```{r}
s = "x, y
A, 1
B, 1
E, 1 
F, 2
E, 2
H, 2"
cand = data.table::fread(s)

### Match candidaes and installed
cand[y== 1,]

### not all of these are true upgrades
cand[y == 2, ]
```
```{r}


# upgrade if cand in 2, but not installed in 1
cand[y ==2, ][!dt[y == 1, ], on=.(x)]

# ignore, if cand in 2 AND was installed in 1 (previously)
cand[y ==2, ][dt[y == 1, ], on=.(x), nomatch=NULL]
```
```

```{r}
library(data.table)

dt1 <- data.table(A1=letters[1:10], B1=sample(1:5,10, replace=TRUE))
dt2 <- data.table(A2=letters[c(1:5, 11:15)], B2=sample(1:5,10, replace=TRUE))

setkey(dt1, A1)
setkey(dt2, A2)
dt1
#     A1 B1
#  1:  a  4
#  2:  b  1
#  3:  c  3
#  4:  d  1
#  5:  e  3
#  6:  f  4
#  7:  g  3
#  8:  h  5
#  9:  i  1
# 10:  j  3

dt2
#     A2 B2
#  1:  a  3
#  2:  b  5
#  3:  c  2
#  4:  d  4
#  5:  e  3
#  6:  k  4
#  7:  l  4
#  8:  m  5
#  9:  n  4
# 10:  o  5

```
```{r}

`A new "!" prefix on i signals 'not-join' (a.k.a. 'not-where'), #1384.
  DT[-DT["a", which=TRUE, nomatch=0]]   # old not-join idiom, still works
  DT[!"a"]                              # same result, now preferred.
  DT[!J(6),...]                         # !J == not-join
  DT[!2:3,...]                          # ! on all types of i
  DT[colA!=6L | colB!=23L,...]          # multiple vector scanning approach
  DT[!J(6L,23L)]                        # same result, faster binary search
'!' has been used rather than '-' :
  * to match the 'not-join' and 'not-where' nomenclature
  * with '-', DT[-0] would return DT rather than DT[0] and not be backwards
    compatibile. With '!', DT[!0] returns DT both before (since !0 is TRUE in
    base R) and after this new feature.
  * to leave DT[+...] and DT[-...] available for future use``
```
