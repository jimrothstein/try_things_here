---
title: "`r knitr::current_input()`"
date: "`r paste('last updated', 
    format(lubridate::now(), ' %d %B %Y'))`"
output: 
  pdf_document:
    latex_engine: lualatex
    toc:  TRUE
    toc_depth:  4
  html_document:  
        code_folding: show
        toc: true 
        toc_depth: 4
        toc_float: true
        mathjax: default
fontsize: 12pt
geometry: margin=0.5in,top=0.25in
---
\small{make small}

```{r setup, include=FALSE		}
knitr::opts_chunk$set(echo = TRUE,  comment="      ##",  error=TRUE, 
                      collapse=F)
```

```{r library, include=FALSE} 
library(jimTools)
```



### What is Symbol?

 *  Lisp calls it symbol
 *  S calls it name
 *  Symbols refer to R objects. The name of any R object is usually a symbol. Symbols can be created through the functions as.name and quote. They naturally appear as atoms of parsed expressions, try e.g. as.list(quote(x y)).   Ref: R Language 2.1.3.1


#### Create with as.symbol
```{r symbol}
## x is a double
x  <- 5

## turn x into a symbol 
    s  <- as.symbol(x)
    is.symbol(s)
    typeof(s)
    storage.mode(s)
    mode(s)

    if (F) eval(s) #error
```
```{r parse}
p  <- parse(text = "{
## x is a double
x  <- 5

## turn x into a symbol 
    s  <- as.symbol(x)
    is.symbol(s)
    typeof(s)
    storage.mode(s)
    mode(s)

    if (F) eval(s) #error
}"
)
```
####    functions ???
```{r function}
f  <- function() {}

is.symbol(f)
# [1] FALSE

q  <- quote(f)
is.symbol(q)
# [1] TRUE

### FAIL
name  <- as.name(f)
s  <- as.symbol(f)

```


#### Create with as.name 
```{r name}
y  <- 5
name  <- as.name(y)
name
# `5`
is.symbol(name)
# [1] TRUE
storage.mode(name)
typeof(name)
eval(name)  #error
```

#### Create using quote 
```{r quote}
z  <- 5
name  <- quote(z)
# z
typeof(name)
# [1] "symbol"

eval(name)
# [1] 5
```
#### Future shortcut
```{r shortcut}
y  <- 5
name  <- as.name(y)

sapply(list(is.symbol, 
            typeof, 
            mode, 
            storage.mode), 
       do.call, list(quote(name)))

# [1] "TRUE"   "symbol" "name"   "symbol"
```


```{r end}
knitr::knitr_exit()
```

rlang::expr | rlang::enexpr
```{r 17.2_code}
rlang::expr(a+b+10)
expr(some_fun(a))

capture_it  <- function(x) expr(x)
capture_it(a+b+10)  #x

capture_it2  <- function(x) enexpr(x)
capture_it2(a+b+10) # returns a+b+10 
capture_it2(caller_env())


# STUDY f
f  <- expr(f(x=1, y=2))
typeof(f)
class(f)
attributes(f)

f   # just its value
f[[1]]  # its name?
f[[2]]
f[[3]]

as_list(f)

# f[[4]]

```
lobstr::ast
```{r 17.3_code}

lobstr::ast(x+y)
lobstr::ast(f(x,y))
lobstr::ast(f(x, g(y)))

lobstr::ast(f(x, g(h(z)), h(z)))
ast( ff  <- expr(f(x,y)))

```

rlang::call2() create function (given a tree) 
```{r 17.4}
# must quote
rlang::call2("f", "y", "z")
rlang::call2("f", 1, 2	)


# inverse!
ast(call2("f", 1, 2	))

#
# error, nice try
# call2(ast(f(x,y)))
```

alternative to call2 to develop code, use !!  unquote
```{r 14.4_contiue}

# quote (makes expression?)
xx  <- expr(x+x) 
yy   <- expr(y + y) 

# create R code: (uquote expression?)
expr(!!xx/!!yy)

# inverse!
ff  <- expr(f(x,y))
expr(!!ff)


# create code

f  <- function(var){
	var  <- enexpr(var)  # capture
	expr(3*(!!var))  # do something, and capture this.
}
f(x)
f(x+y)
f(f(x))
f(1+3+x)

# Hadley's example:
cv <- function(var) {
  var <- enexpr(var)
  expr(sd(!!var) / mean(!!var))
}

```






```{r render}
file <- "017_metaprogramming.Rmd"
file  <- normalizePath(file)
file


rmarkdown::render( file,
                    output_format = "pdf_document",
                    output_dir="~/Downloads/print_and_delete") 
)
```
