head(mtcars, n=3)
?options
getOption(n,head())
getOption("n", head())
?head
head
head = function(..., n=3) head(..., n=3)
head(mtcars)
head = function(df = NULL, n=3) head(df, n)
head(mtcars)
head = function(df = NULL, n=3) utils::head(df, n)
head(mtcars)
mtcars[1:5, c("hp")]
# works
mtcars[1:5, c("hp")]
# fails
mtcars[1:5, hp]
ls()
search()
code = expr(mean(cyl+am))
typeof(code)
is.expression(code)
rlang::is_expression(code)
eval(code, envir=mtcars, enclos=as.environment("packaage:base"))
eval(code, envir=mtcars, enclos=as.environment("package:base"))
search()
eval(code, envir=mtcars, enclos=as.environment("package:stats"))
eval(code, envir=mtcars, enclos=as.environment("tools:rstudio"))
eval(code, envir=mtcars, enclos=globalenv())
eval(code, envir=mtcars)
#   RESTART
ls()
search()
code = expr(mean(cyl+am))
typeof(code)
is.expression(code)
rlang::is_expression(code)
eval(code, envir=mtcars)
# EXPLAIN:  why works?
cyl
dplyr::summary(mtcars, .data$cyl)
dplyr::summarize(mtcars, .data$cyl)
dplyr::summarize(mtcars, mean(.data$cyl))
?summarize
cyl = 1000
dplyr::summarize(mtcars, .data$cyl)
dplyr::summarize(mtcars, mean(.data$cyl))
dplyr::summarize(mtcars, mean(.env$cyl))
dplyr::summarize(mtcars, mean(am+cyl))
dplyr::summarize(mtcars, mean(.data$am+cyl))
dplyr::summarize(mtcars, mean(.data$am+.env$cyl))
mtcars$am
digits(3)
options(digits=7)
3
dplyr::summarize(mtcars, mean(.data$am+.env$cyl))
old = options(digits=7)
options(digits=old)
old = options(digits=7)
options(digits=old)
old
options(old)
getOption(digits)
getOption("digits")
?options
old = options(digits=7)
options(old)
getOption("digits")
options(digits=3)
old = options(digits=7)
options(old)
getOption("digits")
getOptions("digits")
getOption("digits")
old = options(digits=7)
options(digits=old)
options(old)
getOption("digits")
old = options(digits=7)
getOption("digits")
options(old)
getOption("digits")
as.environment(mtcars)
search()
loadedNamespaces()
environment()
parent.env(as.environment(mtcars))
ls(empty_env)
ls(empty_env())
SEE:  https://rfordatascience.slack.com/archives/C04LH661EUX/p1679540376937849
Problem:  Try to access directly columns inside a data.frame.
```{r}
SEE:  https://rfordatascience.slack.com/archives/C04LH661EUX/p1679540376937849
library(tibble)
# TODO: use option()
head = function(df = NULL, n=3) utils::head(df, n)
library(tibble)
But using just unquoted col name fails.
environment()
parent.env(environment())
f = function(e) parent.env(e)
f(current_env())
x = vector("list", 20)
x
x[[1]]=  f(current_env())
x
x[[1]]=  f(current_env())
x
x = vector("list", 20)
x
f = function(e) {
if (e == 1) {return(globalenv())
} else {
if (environment(x[[e-1]]) == emptyenv()) return(NULL)
return(parent.env(x[[e-1]]))
}
lapply(1:10, f)
x = vector("list", 20)
x
f = function(e) {
if (e == 1) x[[e]] <<- globalenv()
} else {
f = function(e) {
if (e == 1) x[[e]] <<- globalenv()
if (environment(x[[e-1]]) == emptyenv()) return(NULL)
x[[e]] <-- parent.env(x[[e-1]])
}
lapply(1:10, f)
f = function(e) {
if (e == 1) x[[e]] <<- globalenv()
return()
if (environment(x[[e-1]]) == emptyenv()) return(NULL)
x[[e]] <-- parent.env(x[[e-1]])
}
lapply(1:10, f)
f = function(e) {
if (e == 1) {x[[e]] <<- globalenv()
return()
}
if (environment(x[[e-1]]) == emptyenv()) return(NULL)
x[[e]] <-- parent.env(x[[e-1]])
}
lapply(1:10, f)
f = function(e) {
if (e == 1) {x[[e]] <<- globalenv()
return()
}
if ( identical( x[[e-1]] , emptyenv()) )
return(NULL)
x[[e]] <-- parent.env(x[[e-1]])
}
lapply(1:10, f)
globalenv()
x[[1]] = globalenv()
x
x[[2]] = parent.env(x[[2-1]])
x[1:2]
x = vector("list", 20)
x
f = function(e) {
if (e == 1) {x[[e]] <<- globalenv()
return()
}
if ( identical( x[[e-1]] , emptyenv()) )
return(NULL)
x[[e]] <<- parent.env(x[[e-1]])
}
lapply(1:10, f)
x
search()
x = vector("list", 25)
x
f = function(e) {
if (e == 1) {x[[e]] <<- globalenv()
return()
}
if ( identical( x[[e-1]] , emptyenv()) )
return(NULL)
x[[e]] <<- parent.env(x[[e-1]])
}
lapply(1:10, f)
lapply(1:25, f)
N = length(search())
x = vector("list", N+1)
x
f = function(e) {
if (e == 1) {x[[e]] <<- globalenv()
return()
}
if ( identical( x[[e-1]] , emptyenv()) )
return(NULL)
x[[e]] <<- parent.env(x[[e-1]])
}
i = N+1
lapply(1:i,  f)
e <- new.env(parent=emptyenv())
attach(e)
f = function(e) {
if (e == 1) {x[[e]] <<- globalenv()
return()
}
if ( identical( x[[e-1]] , emptyenv()) )
return(NULL)
x[[e]] <<- parent.env(x[[e-1]])
}
N = length(search())
x = vector("list", N+1)
x
f = function(e) {
if (e == 1) {x[[e]] <<- globalenv()
return()
}
if ( identical( x[[e-1]] , emptyenv()) )
return(NULL)
x[[e]] <<- parent.env(x[[e-1]])
}
i = N+1
lapply(1:i,  f)
search()
e
parent.env(e)
parent.env(base_env())
attach(e)
?where
function(x) 5
y=2
function(y=y) y
\(x) 2
x
x=1
\(x) x
eval(\(x))
ls()
e <- new.env()
e$g <- function() 1
environment(e$g)
# https://www.rostrum.blog/2023/03/03/getparsedata/
#   webD version: https://webr-parse-test.netlify.app/
# https://renkun.me/2020/11/08/using-parse-data-to-analyze-r-code/
# https://github.com/wch/r-source/blob/0ee550ff68f22b8a1807377e728f99f2775cc43c/src/main/gram.y#L2312-L235
#
# PURPOSE:  Basic intro to  parse, token,
#
x <- subset(mtcars, subset = carb == 8)
e <- parse(text = "x = subset(mtcars, subset = carb == 8)")
e
ls(e)
typeof(e)
knitr::opts_chunk$set(echo = TRUE,
comment = "      ##",
error = TRUE,
collapse = T   ) # T easier to read
# args(parse)
e  <-  parse(text = "2^2")
e
##  e is expression, which is based on list
is.expression(e)
## Rmk:  a is unknown, but fine for expression.
e2  <- parse(text = "2*a")
##  An expression can have attributes.
attributes(e)
length(e)
e[[1]]
## Using character vector, sapply will provide name
l  <- c("class", "typeof", "attributes","is.language", "is.expression", "is.pairlist")
sapply(l, do.call, args=list(e))
sapply(l, do.call, args=list(e[[1]]))
length(e)
e[[1]]
library(devtools)
install.packages(devtools)
ls()
any(ls() )
x = 1
y = 2
z = 3
xyz <- bquote(x + y + z)                ##    (x + y + z)
(xyz <- bquote(x + y + z))                ##    (x + y + z)
bquote(hello)
bquote("hello")
bquote(x)
rm(x)
bquote(x)
xyz
is.expression(xyz)
is.character(xyz)
typeof(xyz)
is.call(xyz)
eval(xyz)
x = 1
y = 2
z = 3
eval(xyz)
bquote(hello)
(res = (bquote(hello)))
is.call(res)
is.character(res)
is.expression(res)
is.symbol(res)
eval(res)
(res = (bquote("hello")))
is.call(res)
is.character(res)
is.expression(res)
is.symbol(res)          ## TRUE
eval(res)               ## Error, b/c no object
bquote(~x+y)
(res = bquote(~x+y))
(res = bquote(~x+y))    ## ~x+y
is.call(res)
is_formula(res)
##    bquote also allows parts to be quote and parts to be evaluated immediately
bquote(-.(xyz) / 2)    ## TRUE
x = "jim"
bquote(my names is .(x))
eval(bquote("my name is .(x)   ")))
eval(bquote("my name is .(x)   "))
#-----------------------------
eval(bquote("my name is .(x)   "))
x = "jim"
#-----------------------------
eval(bquote("my name is .(x)   "))
x = "jim"
#-----------------------------
x = "jim"
bquote(my names is .(x))
eval(bquote("my name is .(x)   "))
eval(bquote("my name is " .(x)   ))
eval(bquote("my name is .(x)   "))
eval(bquote("my name is  .(x)   ))
x = "jim"
bquote(my names is .(x))            ## error
eval(bquote("my name is .(x)   "))
eval(bquote("my name is  .(x)   ))
eval(bquote("my name is .(x)   "))
eval(bquote("my name is"  .(x)   ))
eval(bquote("my name is .(x)   ", splice=TRUE))
eval(bquote("my name is"  .(x)   , splice=TRUE))
bquote(my names is .(x), splice=TRUE)            ## error
eval(bquote("my name is .(x)   ", splice=TRUE))
eval(bquote("my name is"  .(x)   , splice=TRUE))
bquote("answer = .(x)", splice=TRUE)
bquote("answer = ".(x), splice=TRUE)
bquote("answer = .(x)", splice=TRUE)
bquote("answer = ".(x), splice=TRUE)
bquote("answer = .(x)", splice=TRUE)
bquote("answer = ".(x), splice=TRUE)
x = 1
quote(1 + .(x))   # 1 + .(x)
bquote(1 + .(x))  # 1 + 1
bquote(template + .(x))
bquote(sin(.(x))) # sin(1)
quote(1 + .(x))   # 1 + .(x)
(res=bquote(1 + .(x)))  # 1 + 1
(res=bquote(template + .(x)))
(res=bquote(sin(.(x)))) # sin(1)
(res=bquote(1 + .(x)))  # 1 + 1
is.call(res)
(res=bquote(template + .(x)))
is.call(res)
(res=bquote(sin(.(x)))) # sin(1)
is.call(res)
is.expression(res)
(res=bquote(1 + .(x)))  # 1 + 1
is.call(res)
is.expression(res)
(res=bquote(template + .(x)))
is.call(res)
is.expression(res)
## even when x is undefined
rm(x)
bquote(x)
eval(bquote("my name is .(x)   "))
## but not
x = "jim"
bquote(my names is .(x))            ## error
eval(bquote("my name is .(x)   "))
eval(bquote("my name is"  .(x)   ))
eval(bquote("my name is .(x)   ", splice=TRUE))
x = 1
(res=bquote(sin(.(x)))) # sin(1)
(res=bquote(sin(.(x), splice=TRUE))) # sin(1)
(res=bquote(sin(.(x)), splice=TRUE)) # sin(1)
(res=bquote(sin(.(x+1)))) # sin(1)
(res=bquote(sin(.(x+1)), splice=TRUE)) # sin(1)
?getAnywhere
library(pkgload)
library(rlang)
pkgload::inst("ggplot2") #/home/jim/R/x86...-library/3.6/ggplot2
pkgload::inst("base")   #/usr/lib/R/library/base
library(ggplot2)
install.packages("ggplot2")
library(ggplot2)
install.packages("ggplot2")
library(ggplot2)
getAnywhere(aes)
```{r}
getAnywhere(vapply)
getAnywhere(getAnywhere)
getAnywhere(".rs.restart")
getAnywhere(.rs.restart)
?restart
?.rs
ls()
x
x=
q
ls()
x
ls()
rm(ls())
?rm
rm(list=ls())
ls()
?exists
f = function(arg) substitute(arg)
f(1:10)
x = 10
f(x)
x = 10
y = 100
f(x + y^2)
# z does not exist
f(x+y+z)
w(1:10)
w = function(arg) print(arg)
w(1:10)
w(x)
g = function(arg) deparse(subsitute(arg))
g(1:10)
g = function(arg) deparse(substitute(arg))
g(1:10)
g(x)
g(x + y^2)
g(x + y + z)
g = function(arg) deparse(f(arg))
g(1:10)
f(arg)
g(1:10)   ## "arg"
deparse("hello")
deparse(hello)
?substitute
as.list(g)
ast(g)
lobstr::ast(g)
g
f
as.list(f)
as.list(f(1:10))
f = function(arg) substitute(arg)
f(1:10)
(res = f(1:10))
is.call(res)
e = expression(x+y)
e
(e = expression(x+y))
(e = expression(x+y))     ## expression(x+y)
(e = expression(2+2))
is.expression(e)
as.expression(e)
x = a
(e = expression(x+y))     ## expression(x+y)
as.expression(e)
f = function(x) x^2
is.expression(f)
(e= as.expression(f))
(e = expression(x+y))     ## expression(x+y)
as.expression(e)          ## expression(x+y)
x = a
(e = expression(x+y))     ## expression(x+y)
is.list(e)
is.expression(e)
(as.list(e))
is.list(e)
expression(a+b)
expression("a+b")
expression("a"+b)
f = function(x) x^2
is.expression(f)        ## FALSE
(e= as.expression(f))   ## Error  (closure -> expression, no-no, why?)
as.list(f)
as.expression(2+2)
rm(x)
as.expression(2+x)
as.expression(sin(x = pi/2))
(as.expression(sin(x = pi/2)))
(as.expression(sin(x = pi/2)))    ## looks evaluated to me
(as.expression(sin(x)))    ## looks evaluated to me
as.expression(sin(y))
y = pi/2
as.expression(sin(y))
?as.expression
as.expression(2+2)
expression(2+2)
as.expression(2+x)
expression(2+x)
expresson(sin(x))
expression(sin(x))
expression(sin(x = pi/2))
y=pi/2
expression(f)
e=expression(f)
e
str(e)
ls.str(e)
as.list(e)
ast(e)
e
ast(x=2)
ast(x^2 + y)
ast(f)
f
