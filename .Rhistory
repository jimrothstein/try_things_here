lines(x, y2, pch = 18, col = "blue", type = "b", lty = 2)
# Add a legend to the plot
legend("topleft", legend=c("Line 1: x*x", "Line 2: 2*x*x"),
col=c("red", "blue"), lty = 1:2, cex=0.8)
# Create some variables
x <- 1:10
y <- 5
# Gives first line
plot(x, y, type = "b", frame = FALSE, pch = 19,
col = "red", xlab = "x", ylab = "y")
y <- rep(x=5,  times=1)
y <- rep(x=5,  times=9)
# Create some variables
x <- 1:10
y <- rep(x=5,  times=9)
# Gives first line
plot(x, y, type = "b", frame = FALSE, pch = 19,
col = "red", xlab = "x", ylab = "y")
y
y <- rep(x=5,  times=length(x))
y
# Gives first line
plot(x, y, type = "b", frame = FALSE, pch = 19,
col = "red", xlab = "x", ylab = "y")
lines(x,y, pch=18, col="blue", type="b", lty=3)
# Gives first line
plot(x, y, type = "b", frame = FALSE, pch = 19,
col = "red", xlab = "x", ylab = "y")
lines(x,y, pch=18, col="blue", type="b", lty=3)
lines(x,y=rep(4, times=length(x)), pch=18, col="blue", type="b", lty=3)
lines(x,y=rep(3, times=length(x)), pch=18,cex=5,  col="blue", type="b", lty=3)
head(mtcars)
mtcars[1:5, hp]
mtcars[1:5, c(hp)]
mtcars[1:5, c("hp")]
mtcars[1:5, hp]
mtcars[1:5, "hp"]
ls()
hp
with(mtcars, hp)
?with
ls()
search()
ls(globalenv())
ls(base)
?ls
ls("package:base")
?data
data(mtcars)
search()
ls()
rm(mtcars)
ls()
# This puts data in globalenv()
data(mtcars)
ls(base)
ls()
rm(mtcars)
ls()
mtcars[1:5, ]
ls()
exists("mtcars",
envir = as.environment("package:datasets"),
inherits = FALSE)
exists("mtcars",
envir = as.environment("package:datasets"),
inherits = FALSE)
exists("hp",
envir = as.environment("package:datasets"),
inherits = FALSE)
exists("hp",
envir = as.environment("package:datasets"),
inherits = T)
is.defined <- function(sym) {
sym <- deparse(substitute(sym))
env <- parent.frame()
exists(sym, env)
}
is.defined(a)
# FALSE
a <- 10
is.defined(a)
any(sapply(1:(which(search() == "tools:rstudio") - 1L),
function(pp) exists(mtcars,  where = pp, inherits = FALSE)))
any(sapply(1:(which(search() == "tools:rstudio") - 1L),
function(pp) exists("mtcars",  where = pp, inherits = FALSE)))
(which(search() == "tools:rstudio")
)
(which(search() == "tools:rstudio") -1L )
search()
which(search() == ".GlobalEnv")
which(search() == "package:base")
:w
which(search() == "package:base")
---
title: "Untitled"
---
title: "Untitled"
iris <- as_tibble(iris)
# across() -----------------------------------------------------------------
# Different ways to select the same set of columns
# See <https://tidyselect.r-lib.org/articles/syntax.html> for details
iris %>%
mutate(across(c(Sepal.Length, Sepal.Width), round))
# across() -----------------------------------------------------------------
# Different ways to select the same set of columns
# See <https://tidyselect.r-lib.org/articles/syntax.html> for details
iris %>%
mutate(across(c(Sepal.Length, Sepal.Width), round)) |> head()
# across() -----------------------------------------------------------------
# Different ways to select the same set of columns
# See <https://tidyselect.r-lib.org/articles/syntax.html> for details
iris |>
mutate(across(c(Sepal.Length, Sepal.Width), round)) |> head()
iris
# across() -----------------------------------------------------------------
# Different ways to select the same set of columns
# See <https://tidyselect.r-lib.org/articles/syntax.html> for details
iris |>
mutate(across(c(Sepal.Length, Sepal.Width), round)) |> head()
iris <- as_tibble(iris)
# across() -----------------------------------------------------------------
# Different ways to select the same set of columns
# See <https://tidyselect.r-lib.org/articles/syntax.html> for details
iris |>
mutate(across(c(Sepal.Length, Sepal.Width), round)) |> head()
#| errors:  true
head(mtcars, n=3)
?options
getOption(n,head())
getOption("n", head())
?head
head
head = function(..., n=3) head(..., n=3)
head(mtcars)
head = function(df = NULL, n=3) head(df, n)
head(mtcars)
head = function(df = NULL, n=3) utils::head(df, n)
head(mtcars)
mtcars[1:5, c("hp")]
# works
mtcars[1:5, c("hp")]
# fails
mtcars[1:5, hp]
ls()
search()
code = expr(mean(cyl+am))
typeof(code)
is.expression(code)
rlang::is_expression(code)
eval(code, envir=mtcars, enclos=as.environment("packaage:base"))
eval(code, envir=mtcars, enclos=as.environment("package:base"))
search()
eval(code, envir=mtcars, enclos=as.environment("package:stats"))
eval(code, envir=mtcars, enclos=as.environment("tools:rstudio"))
eval(code, envir=mtcars, enclos=globalenv())
eval(code, envir=mtcars)
#   RESTART
ls()
search()
code = expr(mean(cyl+am))
typeof(code)
is.expression(code)
rlang::is_expression(code)
eval(code, envir=mtcars)
# EXPLAIN:  why works?
cyl
dplyr::summary(mtcars, .data$cyl)
dplyr::summarize(mtcars, .data$cyl)
dplyr::summarize(mtcars, mean(.data$cyl))
?summarize
cyl = 1000
dplyr::summarize(mtcars, .data$cyl)
dplyr::summarize(mtcars, mean(.data$cyl))
dplyr::summarize(mtcars, mean(.env$cyl))
dplyr::summarize(mtcars, mean(am+cyl))
dplyr::summarize(mtcars, mean(.data$am+cyl))
dplyr::summarize(mtcars, mean(.data$am+.env$cyl))
mtcars$am
digits(3)
options(digits=7)
3
dplyr::summarize(mtcars, mean(.data$am+.env$cyl))
old = options(digits=7)
options(digits=old)
old = options(digits=7)
options(digits=old)
old
options(old)
getOption(digits)
getOption("digits")
?options
old = options(digits=7)
options(old)
getOption("digits")
options(digits=3)
old = options(digits=7)
options(old)
getOption("digits")
getOptions("digits")
getOption("digits")
old = options(digits=7)
options(digits=old)
options(old)
getOption("digits")
old = options(digits=7)
getOption("digits")
options(old)
getOption("digits")
as.environment(mtcars)
search()
loadedNamespaces()
environment()
parent.env(as.environment(mtcars))
ls(empty_env)
ls(empty_env())
SEE:  https://rfordatascience.slack.com/archives/C04LH661EUX/p1679540376937849
Problem:  Try to access directly columns inside a data.frame.
```{r}
SEE:  https://rfordatascience.slack.com/archives/C04LH661EUX/p1679540376937849
library(tibble)
# TODO: use option()
head = function(df = NULL, n=3) utils::head(df, n)
library(tibble)
But using just unquoted col name fails.
environment()
parent.env(environment())
f = function(e) parent.env(e)
f(current_env())
x = vector("list", 20)
x
x[[1]]=  f(current_env())
x
x[[1]]=  f(current_env())
x
x = vector("list", 20)
x
f = function(e) {
if (e == 1) {return(globalenv())
} else {
if (environment(x[[e-1]]) == emptyenv()) return(NULL)
return(parent.env(x[[e-1]]))
}
lapply(1:10, f)
x = vector("list", 20)
x
f = function(e) {
if (e == 1) x[[e]] <<- globalenv()
} else {
f = function(e) {
if (e == 1) x[[e]] <<- globalenv()
if (environment(x[[e-1]]) == emptyenv()) return(NULL)
x[[e]] <-- parent.env(x[[e-1]])
}
lapply(1:10, f)
f = function(e) {
if (e == 1) x[[e]] <<- globalenv()
return()
if (environment(x[[e-1]]) == emptyenv()) return(NULL)
x[[e]] <-- parent.env(x[[e-1]])
}
lapply(1:10, f)
f = function(e) {
if (e == 1) {x[[e]] <<- globalenv()
return()
}
if (environment(x[[e-1]]) == emptyenv()) return(NULL)
x[[e]] <-- parent.env(x[[e-1]])
}
lapply(1:10, f)
f = function(e) {
if (e == 1) {x[[e]] <<- globalenv()
return()
}
if ( identical( x[[e-1]] , emptyenv()) )
return(NULL)
x[[e]] <-- parent.env(x[[e-1]])
}
lapply(1:10, f)
globalenv()
x[[1]] = globalenv()
x
x[[2]] = parent.env(x[[2-1]])
x[1:2]
x = vector("list", 20)
x
f = function(e) {
if (e == 1) {x[[e]] <<- globalenv()
return()
}
if ( identical( x[[e-1]] , emptyenv()) )
return(NULL)
x[[e]] <<- parent.env(x[[e-1]])
}
lapply(1:10, f)
x
search()
x = vector("list", 25)
x
f = function(e) {
if (e == 1) {x[[e]] <<- globalenv()
return()
}
if ( identical( x[[e-1]] , emptyenv()) )
return(NULL)
x[[e]] <<- parent.env(x[[e-1]])
}
lapply(1:10, f)
lapply(1:25, f)
N = length(search())
x = vector("list", N+1)
x
f = function(e) {
if (e == 1) {x[[e]] <<- globalenv()
return()
}
if ( identical( x[[e-1]] , emptyenv()) )
return(NULL)
x[[e]] <<- parent.env(x[[e-1]])
}
i = N+1
lapply(1:i,  f)
e <- new.env(parent=emptyenv())
attach(e)
f = function(e) {
if (e == 1) {x[[e]] <<- globalenv()
return()
}
if ( identical( x[[e-1]] , emptyenv()) )
return(NULL)
x[[e]] <<- parent.env(x[[e-1]])
}
N = length(search())
x = vector("list", N+1)
x
f = function(e) {
if (e == 1) {x[[e]] <<- globalenv()
return()
}
if ( identical( x[[e-1]] , emptyenv()) )
return(NULL)
x[[e]] <<- parent.env(x[[e-1]])
}
i = N+1
lapply(1:i,  f)
search()
e
parent.env(e)
parent.env(base_env())
attach(e)
?where
function(x) 5
y=2
function(y=y) y
\(x) 2
x
x=1
\(x) x
eval(\(x))
ls()
e <- new.env()
e$g <- function() 1
environment(e$g)
# https://www.rostrum.blog/2023/03/03/getparsedata/
#   webD version: https://webr-parse-test.netlify.app/
# https://renkun.me/2020/11/08/using-parse-data-to-analyze-r-code/
# https://github.com/wch/r-source/blob/0ee550ff68f22b8a1807377e728f99f2775cc43c/src/main/gram.y#L2312-L235
#
# PURPOSE:  Basic intro to  parse, token,
#
x <- subset(mtcars, subset = carb == 8)
e <- parse(text = "x = subset(mtcars, subset = carb == 8)")
e
ls(e)
typeof(e)
knitr::opts_chunk$set(echo = TRUE,
comment = "      ##",
error = TRUE,
collapse = T   ) # T easier to read
# args(parse)
e  <-  parse(text = "2^2")
e
##  e is expression, which is based on list
is.expression(e)
## Rmk:  a is unknown, but fine for expression.
e2  <- parse(text = "2*a")
##  An expression can have attributes.
attributes(e)
length(e)
e[[1]]
## Using character vector, sapply will provide name
l  <- c("class", "typeof", "attributes","is.language", "is.expression", "is.pairlist")
sapply(l, do.call, args=list(e))
sapply(l, do.call, args=list(e[[1]]))
length(e)
e[[1]]
library(devtools)
install.packages(devtools)
ls()
any(ls() )
x = 1
y = 2
z = 3
xyz <- bquote(x + y + z)                ##    (x + y + z)
(xyz <- bquote(x + y + z))                ##    (x + y + z)
bquote(hello)
bquote("hello")
bquote(x)
rm(x)
bquote(x)
xyz
is.expression(xyz)
is.character(xyz)
typeof(xyz)
is.call(xyz)
eval(xyz)
x = 1
y = 2
z = 3
eval(xyz)
bquote(hello)
(res = (bquote(hello)))
is.call(res)
is.character(res)
is.expression(res)
is.symbol(res)
eval(res)
(res = (bquote("hello")))
is.call(res)
is.character(res)
is.expression(res)
is.symbol(res)          ## TRUE
eval(res)               ## Error, b/c no object
bquote(~x+y)
(res = bquote(~x+y))
(res = bquote(~x+y))    ## ~x+y
is.call(res)
is_formula(res)
##    bquote also allows parts to be quote and parts to be evaluated immediately
bquote(-.(xyz) / 2)    ## TRUE
x = "jim"
bquote(my names is .(x))
eval(bquote("my name is .(x)   ")))
eval(bquote("my name is .(x)   "))
#-----------------------------
eval(bquote("my name is .(x)   "))
x = "jim"
#-----------------------------
eval(bquote("my name is .(x)   "))
x = "jim"
#-----------------------------
x = "jim"
bquote(my names is .(x))
eval(bquote("my name is .(x)   "))
eval(bquote("my name is " .(x)   ))
eval(bquote("my name is .(x)   "))
eval(bquote("my name is  .(x)   ))
x = "jim"
bquote(my names is .(x))            ## error
eval(bquote("my name is .(x)   "))
eval(bquote("my name is  .(x)   ))
eval(bquote("my name is .(x)   "))
eval(bquote("my name is"  .(x)   ))
eval(bquote("my name is .(x)   ", splice=TRUE))
eval(bquote("my name is"  .(x)   , splice=TRUE))
bquote(my names is .(x), splice=TRUE)            ## error
eval(bquote("my name is .(x)   ", splice=TRUE))
eval(bquote("my name is"  .(x)   , splice=TRUE))
bquote("answer = .(x)", splice=TRUE)
bquote("answer = ".(x), splice=TRUE)
bquote("answer = .(x)", splice=TRUE)
bquote("answer = ".(x), splice=TRUE)
bquote("answer = .(x)", splice=TRUE)
bquote("answer = ".(x), splice=TRUE)
x = 1
quote(1 + .(x))   # 1 + .(x)
bquote(1 + .(x))  # 1 + 1
bquote(template + .(x))
bquote(sin(.(x))) # sin(1)
quote(1 + .(x))   # 1 + .(x)
(res=bquote(1 + .(x)))  # 1 + 1
(res=bquote(template + .(x)))
(res=bquote(sin(.(x)))) # sin(1)
(res=bquote(1 + .(x)))  # 1 + 1
is.call(res)
(res=bquote(template + .(x)))
is.call(res)
(res=bquote(sin(.(x)))) # sin(1)
is.call(res)
is.expression(res)
(res=bquote(1 + .(x)))  # 1 + 1
is.call(res)
is.expression(res)
(res=bquote(template + .(x)))
is.call(res)
is.expression(res)
## even when x is undefined
rm(x)
bquote(x)
eval(bquote("my name is .(x)   "))
## but not
x = "jim"
bquote(my names is .(x))            ## error
eval(bquote("my name is .(x)   "))
eval(bquote("my name is"  .(x)   ))
eval(bquote("my name is .(x)   ", splice=TRUE))
x = 1
(res=bquote(sin(.(x)))) # sin(1)
(res=bquote(sin(.(x), splice=TRUE))) # sin(1)
(res=bquote(sin(.(x)), splice=TRUE)) # sin(1)
(res=bquote(sin(.(x+1)))) # sin(1)
(res=bquote(sin(.(x+1)), splice=TRUE)) # sin(1)
