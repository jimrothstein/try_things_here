\(x) 2
x
x=1
\(x) x
eval(\(x))
ls()
e <- new.env()
e$g <- function() 1
environment(e$g)
# https://www.rostrum.blog/2023/03/03/getparsedata/
#   webD version: https://webr-parse-test.netlify.app/
# https://renkun.me/2020/11/08/using-parse-data-to-analyze-r-code/
# https://github.com/wch/r-source/blob/0ee550ff68f22b8a1807377e728f99f2775cc43c/src/main/gram.y#L2312-L235
#
# PURPOSE:  Basic intro to  parse, token,
#
x <- subset(mtcars, subset = carb == 8)
e <- parse(text = "x = subset(mtcars, subset = carb == 8)")
e
ls(e)
typeof(e)
knitr::opts_chunk$set(echo = TRUE,
comment = "      ##",
error = TRUE,
collapse = T   ) # T easier to read
# args(parse)
e  <-  parse(text = "2^2")
e
##  e is expression, which is based on list
is.expression(e)
## Rmk:  a is unknown, but fine for expression.
e2  <- parse(text = "2*a")
##  An expression can have attributes.
attributes(e)
length(e)
e[[1]]
## Using character vector, sapply will provide name
l  <- c("class", "typeof", "attributes","is.language", "is.expression", "is.pairlist")
sapply(l, do.call, args=list(e))
sapply(l, do.call, args=list(e[[1]]))
length(e)
e[[1]]
library(devtools)
install.packages(devtools)
ls()
any(ls() )
x = 1
y = 2
z = 3
xyz <- bquote(x + y + z)                ##    (x + y + z)
(xyz <- bquote(x + y + z))                ##    (x + y + z)
bquote(hello)
bquote("hello")
bquote(x)
rm(x)
bquote(x)
xyz
is.expression(xyz)
is.character(xyz)
typeof(xyz)
is.call(xyz)
eval(xyz)
x = 1
y = 2
z = 3
eval(xyz)
bquote(hello)
(res = (bquote(hello)))
is.call(res)
is.character(res)
is.expression(res)
is.symbol(res)
eval(res)
(res = (bquote("hello")))
is.call(res)
is.character(res)
is.expression(res)
is.symbol(res)          ## TRUE
eval(res)               ## Error, b/c no object
bquote(~x+y)
(res = bquote(~x+y))
(res = bquote(~x+y))    ## ~x+y
is.call(res)
is_formula(res)
##    bquote also allows parts to be quote and parts to be evaluated immediately
bquote(-.(xyz) / 2)    ## TRUE
x = "jim"
bquote(my names is .(x))
eval(bquote("my name is .(x)   ")))
eval(bquote("my name is .(x)   "))
#-----------------------------
eval(bquote("my name is .(x)   "))
x = "jim"
#-----------------------------
eval(bquote("my name is .(x)   "))
x = "jim"
#-----------------------------
x = "jim"
bquote(my names is .(x))
eval(bquote("my name is .(x)   "))
eval(bquote("my name is " .(x)   ))
eval(bquote("my name is .(x)   "))
eval(bquote("my name is  .(x)   ))
x = "jim"
bquote(my names is .(x))            ## error
eval(bquote("my name is .(x)   "))
eval(bquote("my name is  .(x)   ))
eval(bquote("my name is .(x)   "))
eval(bquote("my name is"  .(x)   ))
eval(bquote("my name is .(x)   ", splice=TRUE))
eval(bquote("my name is"  .(x)   , splice=TRUE))
bquote(my names is .(x), splice=TRUE)            ## error
eval(bquote("my name is .(x)   ", splice=TRUE))
eval(bquote("my name is"  .(x)   , splice=TRUE))
bquote("answer = .(x)", splice=TRUE)
bquote("answer = ".(x), splice=TRUE)
bquote("answer = .(x)", splice=TRUE)
bquote("answer = ".(x), splice=TRUE)
bquote("answer = .(x)", splice=TRUE)
bquote("answer = ".(x), splice=TRUE)
x = 1
quote(1 + .(x))   # 1 + .(x)
bquote(1 + .(x))  # 1 + 1
bquote(template + .(x))
bquote(sin(.(x))) # sin(1)
quote(1 + .(x))   # 1 + .(x)
(res=bquote(1 + .(x)))  # 1 + 1
(res=bquote(template + .(x)))
(res=bquote(sin(.(x)))) # sin(1)
(res=bquote(1 + .(x)))  # 1 + 1
is.call(res)
(res=bquote(template + .(x)))
is.call(res)
(res=bquote(sin(.(x)))) # sin(1)
is.call(res)
is.expression(res)
(res=bquote(1 + .(x)))  # 1 + 1
is.call(res)
is.expression(res)
(res=bquote(template + .(x)))
is.call(res)
is.expression(res)
## even when x is undefined
rm(x)
bquote(x)
eval(bquote("my name is .(x)   "))
## but not
x = "jim"
bquote(my names is .(x))            ## error
eval(bquote("my name is .(x)   "))
eval(bquote("my name is"  .(x)   ))
eval(bquote("my name is .(x)   ", splice=TRUE))
x = 1
(res=bquote(sin(.(x)))) # sin(1)
(res=bquote(sin(.(x), splice=TRUE))) # sin(1)
(res=bquote(sin(.(x)), splice=TRUE)) # sin(1)
(res=bquote(sin(.(x+1)))) # sin(1)
(res=bquote(sin(.(x+1)), splice=TRUE)) # sin(1)
?getAnywhere
library(pkgload)
library(rlang)
pkgload::inst("ggplot2") #/home/jim/R/x86...-library/3.6/ggplot2
pkgload::inst("base")   #/usr/lib/R/library/base
library(ggplot2)
install.packages("ggplot2")
library(ggplot2)
install.packages("ggplot2")
library(ggplot2)
getAnywhere(aes)
```{r}
getAnywhere(vapply)
getAnywhere(getAnywhere)
getAnywhere(".rs.restart")
getAnywhere(.rs.restart)
?restart
?.rs
ls()
x
x=
q
ls()
x
ls()
rm(ls())
?rm
rm(list=ls())
ls()
?exists
f = function(arg) substitute(arg)
f(1:10)
x = 10
f(x)
x = 10
y = 100
f(x + y^2)
# z does not exist
f(x+y+z)
w(1:10)
w = function(arg) print(arg)
w(1:10)
w(x)
g = function(arg) deparse(subsitute(arg))
g(1:10)
g = function(arg) deparse(substitute(arg))
g(1:10)
g(x)
g(x + y^2)
g(x + y + z)
g = function(arg) deparse(f(arg))
g(1:10)
f(arg)
g(1:10)   ## "arg"
deparse("hello")
deparse(hello)
?substitute
as.list(g)
ast(g)
lobstr::ast(g)
g
f
as.list(f)
as.list(f(1:10))
f = function(arg) substitute(arg)
f(1:10)
(res = f(1:10))
is.call(res)
e = expression(x+y)
e
(e = expression(x+y))
(e = expression(x+y))     ## expression(x+y)
(e = expression(2+2))
is.expression(e)
as.expression(e)
x = a
(e = expression(x+y))     ## expression(x+y)
as.expression(e)
f = function(x) x^2
is.expression(f)
(e= as.expression(f))
(e = expression(x+y))     ## expression(x+y)
as.expression(e)          ## expression(x+y)
x = a
(e = expression(x+y))     ## expression(x+y)
is.list(e)
is.expression(e)
(as.list(e))
is.list(e)
expression(a+b)
expression("a+b")
expression("a"+b)
f = function(x) x^2
is.expression(f)        ## FALSE
(e= as.expression(f))   ## Error  (closure -> expression, no-no, why?)
as.list(f)
as.expression(2+2)
rm(x)
as.expression(2+x)
as.expression(sin(x = pi/2))
(as.expression(sin(x = pi/2)))
(as.expression(sin(x = pi/2)))    ## looks evaluated to me
(as.expression(sin(x)))    ## looks evaluated to me
as.expression(sin(y))
y = pi/2
as.expression(sin(y))
?as.expression
as.expression(2+2)
expression(2+2)
as.expression(2+x)
expression(2+x)
expresson(sin(x))
expression(sin(x))
expression(sin(x = pi/2))
y=pi/2
expression(f)
e=expression(f)
e
str(e)
ls.str(e)
as.list(e)
ast(e)
e
ast(x=2)
ast(x^2 + y)
ast(f)
f
f = function(fun, args=NULL) {
deparse(substitute(fun))
#cat(as.character(typeof(new)), "\n")     ## symbol
}
typeof(f(mean))                 ## character
w = function(arg) print(arg)    ## normal
f = function(arg) substitute(arg) ## substitute
w(1:10)     #  1 2 3 ... 10
(res = f(1:10))     ## 1:10, which is a call.
is.call(res
)
res
w(x)        # 10
x = 10
w(x)        # 10
f(x)
x = 10
y = 100
f(x + y^2)
# z does not exist
f(x+y+z)
r1 = quote(x + 5*3)
r2 = substitute(x + 5*3 )
is.call(r1,r2)
is.call(list(r1,r2))
is.call(r1)
is.call(r2)
eval(r1)
eval(r2)
f <- function(argX) {
list(argX,
quote(argX),
substitute(argX)
)
}
suppliedArgX <- 100
f(argX  <-  suppliedArgX)
f(argX = suppliedArgX)
f(suppliedArgX)
##  Use deparse to convert to stirng
g = function(arg) deparse(substitute(arg))
g(1:10)
g(x)
g(x + y^2)
g(x + y + z)
library(tibble)
library(jsonlite)
library(tidyverse)
library(purrr)
library(repurrrsive)  # recursive lists, R, JSON, ...
install.packages(c("purrr", "repurrrsive", "listviewer"))
library(purrr)
library(repurrrsive)  # recursive lists, R, JSON, ...
library(listviewer)   # interactive exam
##  Helper
#'  list.len = 3   peers
#'  vec.len  = 1   for each vector, # elements to display
g <- function(x,max.level=1,list.len=3, vec.len=1, give.attr=F, ...) {
cat("max.level=", max.level, "list.len (peers)=", list.len,"vec.len (elements)", vec.len,  "\n")
str(x, max.level, list.len, vec.len, give.attr, ...)
}
g(gh_repos)
# show list of datasets
data(package="repurrrsive")
##  examine TODO:  get strucutre of gh_users, use str
listviewer::jsonedit(gh_users)
dput(gh_users[][[1]])
g(gh_users)
g(gh_users[[1]])
gh_users[[1]]
gh_users[1][[1]]
length(gh_users[1])
length(gh_users[1][[1]])
dput(gh_users[1])
g(gh_users[1], vec.len=4)
dput(gh_users[1])
dput(gh_users[1][1:6])
gh_users[1][1:6]
g(gh_users)         # list of 6
g(gh_users[[1]])
g(gh_users[[1]], vec.len=4)
g(gh_users[[1]], list.len=4)
str(gh_users[1])
gh_users[[1]]
gh_users[[1]][c(1,2,3)]
gh_users[[1]][1:3]
gh_users[[2]][1:3]
g(gh_users[[1]][1:3])
g(gh_users[[1]])
gh_users[[1]][1:3]
str(gh_users[[1]])
str(gh_users[[1]], vec.len=3)
str(gh_users[[1]], list.len=3)
g(gh_users[[1]], list.len=3 )
str(gh_users[[1]], list.len=4)
library(tibble)
library(jsonlite)
library(dplyr)
library(listviewer)
library(tidyr)
library(tibble)
library(jsonlite)
library(dplyr)
library(listviewer)
library(tidyr)
```{r}
##  no attempt to simplify
##  x is a list of lists
x <- jsonlite::read_json(the_file)
```{r}
library(tibble)
library(jsonlite)
library(dplyr)
library(listviewer)
library(tidyr)
the_dir = "bookmarks"
the_file <- paste0(the_dir, "/", "bookmarks-2023-05-24_FF.json")
the_dir
the_file
##  no attempt to simplify
##  x is a list of lists
x <- jsonlite::read_json(the_file)
dir()
the_dir = "~/code/try_things_here/rrapply/bookmarks"
the_file <- paste0(the_dir, "/", "bookmarks-2023-05-24_FF.json")
the_dir
the_file
##  no attempt to simplify
##  x is a list of lists
x <- jsonlite::read_json(the_file)
#   x is list of lenth 10, 9 are singletons, the 10th is list
listviewer::jsonedit(x)     ## list(guid, title, ... children=list(...))
x
##
dput(x[1:9])
x1 <- x$children %>% tibble()
# # A tibble: 4 × 1
x1
x$children
x1 <- x$children %>% tibble()
jsonedit(x1)
# # A tibble: 4 × 1
x1
x$children |> tibble()
x
x$chilrend
t x$children
t=x$children
t
t |> tibble()
library(tibble)
t |> tibble()
x1
typeof(x1)
as.tibble(x1)
##  cross join  (ie all combinations)
df1  <- data.frame(ONE=letters[1:3])
---
##  cross join  (ie all combinations)
df1  <- data.frame(ONE=letters[1:3])
```
---
```{r}
1 + 1
#| echo: false
2 * 2
library(rlang)
library(lobstr)
lobstr::ast(f(x, "y", 1))   # knitr complains about character
lobstr::ast(
f(g(1, 2), h(3, 4, i()))
)
lobstr::ast(
f(g(h(2)))
)
z= 2
lobstr::ast(f(z))
lobstr::ast(f(z = 2))
lobstr::ast(f(eval(z)))
lobstr::ast(f(!!z))
lobstr::ast(f(eval(z))) # does not evaluate !
lobstr::ast(f(!!z))   # evaluates !
lobstr::ast(f(z = 3))
lobstr::ast(f(eval(z))) # does not evaluate !
lobstr::ast(f(!!z))   # evaluates !
lobstr::ast(f(eval(z, envir=parent.frame(2)))) # does not evaluate !
lobstr::ast(f(eval(z, envir=parent.frame()))) # does not evaluate !
ls()
lobstr::ast(f(eval(z, envir=globalenv()))) # does not evaluate !
globalenv()
lobstr::ast(
`<-`(y, `*`(x, 10))
)
####
#   lang::expr returns exactly what typed
####
expr(mean(x, na.rm = TRUE))
####
#   lang::expr returns exactly what typed
####
expr(mean(x, na.rm = TRUE))
expr(10 + 100 + 1000)
arg = warn("boom!")
ignore = function(x) NULL
force = function(x) x
ignore(arg)
force(arg)
arg = warn("boom!")
defuse(arg)
rlang::defuse(arg)
library(tidyverse)
rlang::defuse(arg)
ignore(arg)
force(arg)
force(warn("boom!"))
rlang::defuse(arg)
rlang::expr(force(warn("boom!")))
eval(rlang::expr(force(warn("boom!"))))   # aka capture expression
# why differ?
force(arg)
force(warn("boom!"))
arg = warn("boom!")
ignore = function(x) NULL
force = function(x) x
ignore(arg)
# why differ?
force(arg)
