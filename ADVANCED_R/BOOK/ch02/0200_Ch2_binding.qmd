---
title: "`r knitr::current_input()`"
date: "`r paste('last updated', 
    format(lubridate::now(), ' %d %B %Y'))`"
output:   
  html_document:  
        code_folding: show
        toc: true 
        toc_depth: 2
        toc_float: true
        mathjax: default
  pdf_document:   
    latex_engine: xelatex  
    toc: true
    toc_depth:  2   
fontsize: 11pt   
geometry: margin=0.4in,top=0.25in   
TAGS:  modify-in-place,
---


When R creates an object, a list for example, the object has no name.  Use its `memory address` to refer to it.   You can also `bind` that object to a name, say L.
The object itself has no name.  The value of the name L is the object itself.

```{r setup, include=FALSE		}
knitr::opts_chunk$set(echo = TRUE,
                      comment = "      ##",
                      error = TRUE,
                      collapse = FALSE   ) # easier to read
```


```{r library 		}
# print all labels
file  <- knitr::current_input() 
print(knitr::all_labels())
library(lobstr)
``` 
### 002_binding.R

```{r Ch2}
verify  <- function(obj){
    list(obj_size(obj),
    obj_addr(obj),
    mem_used(),
    ref(obj)
) }


# TEXT
# ======
x <- c(1,2,3)
y  <- x

# not ggod verify(x)
verify(x)

```
verify(x)
[[1]]
80 B

[[2]]
[1] "0x56143aaa3798"

[[3]]
69.94 MB

[[4]]
[1:0x56143aaa3798] <dbl> 
```


# 2.2 Binding Basics

Create object, and bind it to `name` x.  x is reference to object. Value of `x` is object.
```{r}
x  <- c(1,2,3)
y  <- x


# Find identifiers, note the same.   One object, both x, y bound to it.
obj_addr(x)
obj_addr(y)

```
# 2.3.2 Functions
# =================
f <- function(a) { a }
verify(f)

x  <- c(1,2,3)
verify(x)
N  <- "\n"
cat(tracemem(x) , N)

z <- f(x)
verify(z)  # same as x
identical(x,z)  # TRUE
identical(verify(x)[1:2],verify(z)[1:2]) # TRUE

reprex( {
#### 2.3.3 Lists
# ================
l1 <- list(1,2,3)
l2 <- l1

# l1, l2 refer to same object 
identical(lobstr::ref(l1),lobstr::ref(l2))   # T
ref(l1,l2)
ref(l2)

# Obtain identifier of object (remember object has no name)
lobstr::obj_addr(l1[[1]])

# BUT... not so for subsets of list
# ========================
s1  <- l1[1]
s2  <- l2[1]
ref(s1,s2)
identical(s1,s2) # TRUE

identical(lobstr::obj_addr(l1[1]), lobstr::obj_addr(l2[1]))  # FALSE	 

# ...not each subset
lobstr::obj_addr(l1[1])
lobstr::obj_addr(l2[1])
# (OR)
lobstr::obj_addr(s1)
lobstr::obj_addr(s2)

# ... confused by this 
lobstr::ref(l1[1], (l2[1])) } )

# Revised
# =========
library(lobstr)
l1 <- list(1,2,3)
l2 <- l1
ref(l1,l2)

s1 <- l1[1]
s2 <- l2[1]
ref(s1,s2)
# =========
```
```{r tracemem}

library(pryr)
x  <- c(1,2)
pryr::address(x)

# make change
x[2]  <- 4
x
pryr::address(x)  # modify-in-place
```
```{r mem2}
y  <- x
ref(x)
z  <- x
ref(x)
ref(z)


ref(z)
pryr::address(x)
pryr::address(y)

y[2]  <- 4
pryr::address(x)
pryr::address(y)  # changed and copied

```


```{r resume1}
```


# BACK to TEXT
# ==============
# Shallow copy:
l1 <- list(1,2,3)
l2 <- l1
verify(l1)
verify(l2) # SAME

# note CHANGES, afterwards have 6 objects
l2[[3]] <- 4
lobstr::ref(l1, l2)

# ====================
# Example from 2.5.1
# ====================
set.seed(2020)
x  <- data.frame(matrix(runif(5*1e4), ncol=5))
base::tracemem(x)
head(x)

lobstr::sxp(x)
is.list(x) # T
length(x)  # 5
str(x)
x["X1"] # col 1
is.list(x["X1"]) # T, list of 1
x["X1"][[1]]  # examine ,  the vector 
x[1][[1]]  # SAME: contents of list of 1,  the vector 


medians  <- vapply(x, median, numeric(1))
medians
str(medians)   # named num[]
is.numeric(medians) # T

# no run
x[[1]]  # elements of col 1
x[,1]   # same

x[1]    # no such, error

for (i in seq_along(medians)){
			 x[[i]]  <- x[[i]] - medians[[i]]
}
lobstr::ref(x)

# ==================
# base::tracemem()
# ==================
     a <- 1:10
     tracemem(a)
		 ref(a)
     ## b and a share memory
     b <- a
		 ref(a,b)
     b[1] <- 1
		 ref(a,b)
     untracemem(a)


# =============================
# KEEP:  from Hadley video on Lobstr
# https://bit.ly/2Wstv0A
# =============================
x <- 1:10^6
obj_size(x)
ref(x)

y  <- list(x,x,x)
obj_size(y)
ref(y)

# modify y, 1st item in list
# forces copy
y[[1]]  <- NA
obj_size(y)
ref(y)

# rm removes reference, not the object!
rm(x,y)

# BUT, if only 1 ref to object, and you change
# R is smart enough NOT to copy, just modify in place

# garbage collector rmoves object

```
