<!--
  NO LONGER NEED yaml header,  see _quarto.yml
-->
### TODO:
- Replace "check", with tinytest

### PURPOSE:    HELPER:  using dt to update  packages  
<!-- {{{ -->
Outline:  

    -   Check R version, sessionInfo
    -   Check current R library locations, 
    -   Review packages each library
    -   Identify packages in more than ONE directory
    -   (interactive only) update `old` packages (compiled with older R versions)
    -   (interactive only) update any remaining packages
    -   list Env variables
    
Functions:  

    -   update
    -   upgrade
    -   installed.packages
    -   find.package
    -   knitr functions:  <https://cran.r-project.org/web//packages/knitr/knitr.pdf>
<!-- }}} -->

### currently installed pkgs , 266 (with dup)
<!-- {{{ -->
```{r}
library(data.table)
dt = as.data.table(installed.packages())
head(dt)[1:3,1:3 ]
dim(dt) # [1] 264  16
```

### candidates
```{r}
# Notice, some packages appear in two directories
(cand = as.data.table(old.packages()[, c("Package", "LibPath")]))
```

### update immediately, candidates in .libPaths()[[1]]
```{r}
x  <-  cand[LibPath == .libPaths()[[1]],.(Package, LibPath)]
as.matrix(x)

update.packages( lib.loc= .libPaths()[[1]],
  ask = F,    ## TRUE means asks for each pkg
                oldPkgs = as.matrix(x),         # ONLY these packages updated
                instlib = .libPaths()[[1]],       # gives WARNING that R_HOME not writable
                checkBuilt=T)

# check, expect no candidates in [1]
cand = as.data.table(old.packages()[, c("Package", "LibPath")])
cand[LibPath == .libPaths()[[1]]]
```

### .libPaths()[[2]]
```{r}
# remaining candidates are all in [2]
cand[LibPath == .libPaths()[[1]]]   # expect empty
cand[LibPath == .libPaths()[[2]]]

# ONlY candidates to find:   of all candidates in 2, which have NO installed in 1?
# if not empty, upgrade those packges
cand[!dt[LibPath == .libPaths()[[1]]], on = .(Package)]


# any of these ALSO in 1?
dt[cand[LibPath == .libPaths()[[2]]], on = .(Package), nomatch=NULL][, .(Package, LibPath)]

# restrict to display [1], inner join to see if any candidate in [2] matches package installed in [1]
dt[LibPath == .libPaths()[[1]],][cand[LibPath == .libPaths()[[2]]], on = .(Package), nomatch=NULL][, .(Package, LibPath)]

```

### anti-join, a simple example

###### LeGACY
