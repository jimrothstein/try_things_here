
	 vim:linebreak:nowrap:nospell:cul tw=78 fo=tqlnr foldcolumn=3 
	 
--- 
# Spaces, no Tabs
title: Template for .Rmd 
date: "`r paste('last updated', 
    format(lubridate::now(), '%H:%M, %d %B %Y'))`"
output: 
  pdf_document: 
    latex_engine: lualatex
toc: TRUE 
toc_depth:  1 
fontsize: 12pt 
geometry: margin=0.5in,top=0.25in 
TAGS:  match.call, do.call, useMethod, match.args
---

```{r setup, include=FALSE		}
knitr::opts_chunk$set(echo = TRUE,  
											comment="      ##",  
											error=TRUE, 
											collapse=TRUE) 
library(jimTools) 
```
#### Call: Unevaluted function, where args ARE evaluated. Function is NOT a
call.
```{r intro_call}
    f  <- function(x) {
	x^2}

    # create a call
    (cl  <- call("f", 3))
    # f(3)

    ##  Test for call.
	sapply(list(f, "f", cl), is.call) # [1] FALSE FALSE  TRUE
    ##  To evaluate a call.
	eval(cl) # [1] 9
```

### do.call use case  
* (differs from most examples here)
```{r use_case}
##  Suppose long list of arguments  (here only 3)
g  <- function(x,y,z) {x+y+z}

##  package the values in a list AND run the function
do.call("g", list(1,2,3))
# [1] 6
```


### match.call() 
* match function's arguments (formals) and values presented
* returns object call; unevaluated function, but with arguments evaluated.
* use inside a function.
* use as.list.
* [1] is name of function.
* [2:n] are UNevaluated args.  (ie symbols are ok)
```{r match.call}
## return in 1 line; without as.list (I like better)
    g  <- function(x, y, z){
      return(match.call())
    }
    g(1,2,3)
# g(x = 1, y = 2, z = 3)
    is.call(g(1,2,3))
# [1] TRUE
    is.call(g)
# [1] FALSE

## OR, with as.list
    g  <- function(x, y, z){
      return(as.list(match.call()))
    }


# Examples
g(1,2,3)

# drop 1st element
g(1,2,3)[-1]

g(a,b,c)

# Study
l  <- g(a,b,c)
l
str(l)

# Example
l  <- g(1+3, b, c+0)
l
str(l)
```

# file <- "4010_match_call_examples.Rmd"

#### if call uses an abbrevation, return with a call using full argument names
```{r example2}

f  <- function(abc = 1, xyz =0) match.call()
f(a=1, x=1)
# f(abc = 1, xyz = 1)

# SAME, but verify call 
if (is.call(f(a=1, x=1)))  {
  f(a=1, x=1)
}
## f(abc = 1, xyz = 1)

##  NOTE:  Still a valid `call`
f(r,s)          
# f(abc = r, xyz = s)

f(a=1)
# f(abc = 1)

f()
# f()

## returns error
if (F) f(y=1)

is.call(f())
# [1] TRUE
typeof(f())
# [1] "language"
```


### do.call vs lapply
  *  do.call(what, args as list)
```{r do_call_simple}
# make just one call
do.call("sum", list(1,2,3))

# compare   (sum or "sum", samme)
# makes call for each item in list
lapply(list(1,2,3), sum)
[[1]]
[1] 1

[[2]]
[1] 2

[[3]]
[1] 3
```


### match.call , in real life
  *  use case:
  *  do.call(what, args), where `what` is function, args is list
  *  here:  match.call()[-1] drops 1st element (function) 

```{r begin}
f <- function(x, y, z) {
  do.call("sum", as.list(match.call()[-1])) 
}

f(1, 2, 3)


```

### match.arg, 
  *   limit possible input values

```{r match.arg}

f  <- function(type=c("a", "b")){
  type  <- match.arg(type)}

(f("b"))  # chr[]   "b"
(f("c")) #Error, not "a" or "b"
```

### Unicode:
  *   How to use unicode!
```{r random}
letters <- c(1, 2, 3, 4)
names(letters) <- c("a", "b", "c", "\U1F409")
letters
```


