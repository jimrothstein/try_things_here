---
title: "102_... HELPER.qmd"  
author: "JR"  
date: "5/22/2021"  
pdf-engine: lualatex  
format:   
  html:  
        code-fold: true
        toc: true 
        toc_depth: 3
        toc_float: true
        embed-resources:  true
        code-block-bg: true
        code-block-border-left: "#31BAE9"       
        indent: true
        number-sections: true
        number-depth: 3
        number-offset: 2
        code-link: true             # hyperlink R functions
        html-math-method: katex
        css:  styles.css
execute:
    error: true 
    warning: true
    collapse: true 
    standalone: true
output-dir: docs            ## NO indent, also _quarto.yml for entier project
---

***
This is [DEEPER]{style="color: red;"} HELPER version of 0088_  
[0088 is more streamlined.]{style="background-color: yellow"}.  
Rscripts/jim Tools - is intended for daily produciton

***

### PURPOSE:    Update R packages

Outline:  

    -   Check R version, sessionInfo
    -   Check current R library locations, 
    -   Review packages each library
    -   Identify packages in more than ONE directory
    -   (interactive only) update `old` packages (compiled with older R versions)
    -   (interactive only) update any remaining packages
    -   list Env variables
    
Functions:  

    -   update
    -   upgrade
    -   installed.packages
    -   find.package
    -   knitr functions:  <https://cran.r-project.org/web//packages/knitr/knitr.pdf>


### all installed , 266 (with dup)
<!-- {{{ -->
```{r}
library(data.table)
installed = installed.packages()
dt  <- data.table::as.data.table(installed)
setkey(dt, "Package", "LibPath")
key(dt) # [1] "Package"

head(dt)[1:3,1:3 ]
dim(installed) # [1] 264  16
```<!-- }}} -->

### installed in user dir
<!-- {{{ -->
```{r}
.libPaths()
dt_user = dt[LibPath == .libPaths()[[1]]]
key(dt_user)
dim(dt_user) # [1] 235  16
```<!-- }}} -->

### installed in system dir  ("standard library")
<!-- {{{ -->
```{r}
dt_sys = dt[LibPath == .libPaths()[[2]]]
dim(dt_sys) # [1] 29 16
```<!-- }}} -->


### unique packages, ~ 9 duplicates
<!-- {{{ -->
```{r}
data.table::uniqueN(dt$Package) # [1] 255
data.table::uniqueN(dt_user$Package) # [1] 235
data.table::uniqueN(dt_sys$Package) # [1] 29
```<!-- }}} -->


REF: https://medium.com/analytics-vidhya/r-data-table-joins-48f00b46ce29
Notation:
  on=.(x,y)
  on=.(x < 5, y> y)  non-equi join
  on=.(...), z := ...   adds column (in reference, no copy)


### Packages in 3 regions, sys_only, user_only, both
<!-- {{{ -->
```{r}
# use inner_join (ie BOTH)
dt_both = dt_user[dt_sys, on=.(Package == Package), nomatch=NULL][, c(1,2)] # 9
dt_both
dt_sys[dt_user, on=.(Package == Package), nomatch=NULL][, c(1,2)] # 9

# !=  is NOT allowed
if (F) dt1[dt2, on=.(Package != Package)][, 1]

# anti-join, all packages in dt_user, not in dt_sys
dt_user_only = dt_user[!dt_sys, on = .(Package)][, c(1,2)] # 226

# anti , packages in dt_sys, not in dt_user
dt_sys_only = dt_sys[!dt_user, on = .(Package)][, c(1,2)] # 20


# A[B, on=.(id), which=T]  returns index only

# check
dt_user[Package=="base"] ; 
  dt_sys[Package=="base"]
dt_user[Package=="boot"]
dt_user[Package=="compiler"]
dt_user[Package=="class"]  # y
```
<!-- }}} -->

### Summary, 3 distinct sets of packages, VERIFY add to total unique
```{r}
dt_user_only
dt_sys_only
dt_both

```


Of 29 packaes in dt_sys, 9 are ALSO in dt_user (20 are not)
<!-- {{{ -->
```{r}
```
<!-- }}} -->


### Update Candidates
```{r find_old  }
.libPaths()

(old1 = old.packages(checkBuilt=T))
# ALL
identical(old1, old.packages(lib.loc=NULL, checkBuilt=T))  # same, all dir 


# our candidaetes
old1
row.names(old1)

## first, find candidate packages; NOT   member of standard library

x = old.packages(lib.loc = .libPaths()[[1]])
(x[x[, 1] == .libPaths()[[2]],,drop=F])

## if not true, update
is.null(x)
update.packages(lib.loc = .libPaths()[[1]],    ## search 
    oldPkgs=x, 
    instlib = .libPaths()[[1]],               ## user, install here
    ask = F
)


## Double check:  find candidates in standard lib AND in user
x= old.packages(lib.loc=.libPaths()[[2]])
x
## subset matrix
(x[x[, 2] == .libPaths()[[1]],,drop=F])
```

### Candidates in std lib, but NOT in user lib
```{r}
## 3rd, find candidates ARE members of std lib AND NOT in user directory 
Z = installed.packages()[, 1:2]
(x = old.packages(lib.loc = .libPaths()[[2]]))   # std library

## TEST, which candidates are in found in user?
x[, 2] 
x[, 1]   # candidate packages in stdlib
x[, 2] == .libPaths()[[1]]  # candidate pkgs also in user

x[, 2] == Z[, 2]
x[x[, 2] ==  Z[, 2]  ]

x[x[,2] == .libPaths()[[1]],]

x[, 1:2]

## if none, upgrade
update.packages(lib.loc = .libPaths()[[2]],    ## search 
    oldPkgs = x,       
    instlib = .libPaths()[[1]],               ## user, install here
    ask = F
)
```

### Finally, candidaetes in user, AND also in std lib
```{r}
(x = old.packages(lib.loc = .libPaths()[[2]]))   # std library
dim(x)
x[ , 2]
x[,2] == .libPaths()[[2]]
x[,2] == .libPaths()[[1]]
x[,2] == installed.packages()[, 2] 
#x[x[, 2] == .libPaths()[1],, DROP=F]  # in user

x[x[,2] == installed.packages()[, 2] ]
# if any packages, update

```

dt_cand = data.table(old1)
dt_cand


# candidates 
#  divide into 3 

dt_cand[dt_user_only, on=.(Package),  nomatch=NULL ]
dt_cand[dt_sys_only, on=.(Package),  nomatch=NULL ]

dt_cand[dt_both, on=.(Package),  nomatch=NULL ]  # only these

```
<!-- BEGIN HERE -->

### CASE # 1 , update OLD in ~/R/4.3.1/...
<!-- {{{ -->
```{r}
# limit to `old` and in User dir  (no warnings, good)
update.packages( lib.loc= .libPaths()[[1]],
                ask = F,    ## TRUE means asks for each pkg
                oldPkgs = old_user,         # ONLY these packages updated
                instlib = .libPaths()[[1]],       
                checkBuilt=T)

```<!-- }}} -->

### DO NOT Update packages in sys (yet)
<!-- {{{ -->
```{r, eval=F}
#      DO NOT RUN !
#
#
# `old` and in /opt directory   , these will ALWAYS want to update.
#  Before doing so, check if already updated and reside in [[1]]
update.packages(lib.loc = .libPaths()[[2]], 
  ask = F,    ## TRUE means asks for each pkg
                oldPkgs = old3,         # ONLY these packages updated
                instlib = .libPaths()[[1]],       # gives WARNING that R_HOME not writable
                checkBuilt=T)
```<!-- }}} -->

### STOP  - need join
### CASE #2 ,  update OLD in area of overlap (ie BOTH user/opt)
# {{{
```{r}
## Do old packages in /opt/R/4.3.1  already have newer versions in ~/R/4.3.1/...
## If so, why recompile all over again?

## TODO:
## each compare with find.package, OR run join against pkgs in ~/R/x86...

# (testing)  All `old` packages in \opt are already in new directory
# triggers a WARNING

update.packages(ask = F,    ## TRUE means asks for each pkg
                oldPkgs = old_sys,         # ONLY these packages updated
                instlib = .libPaths()[[1]],       # avoids WARNING that R_HOME not writable
                checkBuilt=T)

```# }}}
***


### EXAMPLE:  Finally, subset installed
```{r}
x = installed.packages()
x

# matrix Subset 

res  <- x[x[, "Package"] == "yaml",,  drop=F ]
is.matrix(res)
rownames(res)
colnames(res)
attributes(res)

dimnames(res)
dimnames(res)[[1]]
dimnames(res)[[2]]
```

### Example:  simple upgrade candidate (at this time)  "gert"
```{r}
old.packages()
# old.packages() returns "gert", as well as std packages in sys that may not need upgrade

# "gert" package installed on in user dir
(res  <- x[x[, "Package"] == "gert", , drop=F ])

# update gert, and ONLY "gert"
update.packages(lib.loc = .libPaths()[[1]],    ## search 
    oldPkgs=res,     ## non-NULL, update *should* only update these packages
    instlib = .libPaths()[[1]],               ## user, install here
    ask = F
)

## "gert" successfully updated;   now old.packages()  does not include "gert"
```

### Example:  troubled package, "class" is candidate for upgrade (at this time)
```{r}
## 2 entries
(res  <- x[x[, "Package"] == "class", , drop=F ])

## from these 2 rows, choose is sys
(res2  <- res[res[, "LibPath"] == .libPaths()[[2]], , drop=F])

## this is the row  to upgrade !   user
(res2  <- res[res[, "LibPath"] == .libPaths()[[1]], , drop=F])

# about 29, standard packages  in sys

(res  <- x[x[, "LibPath"] == .libPaths()[[2]], c("Package", "LibPath"), drop=F])

```

# check before trying upgrade
```{r}
is.matrix(res)
dimnames(res2)[[1]]
dimnames(res2)[[2]]
attributes(res2)
```

WORKED!   update user lib, "class" package only !
instPkgs = 
```{r}
update.packages(lib.loc = .libPaths()[[1]],    ## search 
    oldPkgs=res2,     ## non-NULL, update *should* only update these packages
    instlib = .libPaths()[[1]],               ## user, install here
    ask = F
)
```






