### /home/jim/code/try_things_here/BASE/604_matrix_pkg_update_HELPER.qmd

PURPOSE:
HELPER:   update packages, using matrix tools (and not dt)


TODO:
  *   Show I1,I2 not unique, have overlap
  *   Show U1, U2 subsets of I
  *   fix comments
  *   LEGACY:   pick out useful

### currently installed, in each of two libraries
```{r}
I1 = installed.packages(lib.loc = .libPaths()[[1]])
I1
I2 = installed.packages(lib.loc = .libPaths()[[2]])
I2

is.matrix(I1)
is.matrix(I2)
```

### `old` in each of two libraries I have (user/sys) 
```{r}
U1 = old.packages( instPkgs = installed.packages(lib.loc = .libPaths()[[1]]))
U2 = old.packages( instPkgs = installed.packages(lib.loc = .libPaths()[[2]]))
U1
U2
is.matrix(U2)
```

### Update candidates in `user`
```{r}
update.packages(ask=F, old = U1 )
```

### Candidates U2 in sys:
# --------------------------
# Case I 
# For those pkgs in candidates in `sys` and already installed in `user`  =>  
DO NOT Upgrade

```{r}
dim(U2[U2[, "Package"] %in% rownames(I1),, drop=F])

if( F) 
update.packages(old = U2, instlib = .libPaths()[[1]]
)
```

# Case II 
# For those pkgs in candidates in `sys` but installed in `user: (ie never were upgraded)
Upgrade 
```{r}
U2[U2[, "Package"] %in% rownames(U2),, drop=F]

# if zero rows, then none of the candidates from lib2 have been previously updated and installed in lib1
U2
```

# --------------
#       LEGACY  - extract useful only
# --------------
### Examine candidate packages against what is currently installed.
```{r}

## Candidate
(cand_packages = z[, 1])
is.matrix(cand_packages)
is.character(cand_packages)

# check all installed 
ins = installed.packages()

# check candidate packages to see installed
ins[ins[, "Package"] %in% cand_packages, 1:2, drop=F]

# CASES: compare candidate to installed
# Any candidates in [1] and NOT in [2] .. upgrade
# Any candidates NOT in [1], but in [2], .. upgrade
# Any candidates in BOTH [1] and [2]  ... upgrade only [1]

z[, "LibPath"] == .libPaths()[[1]]  |
z[, "LibPath"] == .libPaths()[[2]],1:2,drop=F]

# candidates installed in both [1] and [2]
# "Matrix" in [2] and also [1], prior upgrade
z[
z[, "LibPath"] == .libPaths()[[1]]  &
z[, "LibPath"] == .libPaths()[[2]],1:2,drop=F]


# candidates installed in either [1] , not [2]
z[
z[, "LibPath"] == .libPaths()[[1]]  |
!z[, "LibPath"] == .libPaths()[[2]],1:2,drop=F]

# candidates installed in [2], but not [1]  (updade)
(u = z[
!z[, "LibPath"] == .libPaths()[[1]]  |
z[, "LibPath"] == .libPaths()[[2]],1:2,drop=F])

# in [2], but not in [1] update
update.packages(lib.loc = .libPaths()[[2]], 
                ask = F,    ## TRUE means asks for each pkg
                oldPkgs = u,         # ONLY these packages updated
                instlib = .libPaths()[[1]],       # gives WARNING that R_HOME not writable
                checkBuilt=T)

# check


is.matrix(
z[z[, "LibPath"] == .libPaths()[[2]],1:2, drop=F] 
  )
is.matrix(
z[z[, "LibPath"] == .libPaths()[[2]],1:2 ]
)


```
### installed.packages
```{r}

e = installed.packages()
is.matrix(e)

## Check any of these packages installed more than once?
e[e[, "Package"] %in% c("Matrix", "KernSmooth", "mgcv", "nlme", "spatial"),1:2, drop=F]
```



<!-- BEGIN HERE:  subset matrices, based on condition -->




### EXAMPLE:  Finally, subset installed
```{r}
x = installed.packages()
x

# matrix Subset 

res  <- x[x[, "Package"] == "yaml",,  drop=F ]
is.matrix(res)
rownames(res)
colnames(res)
attributes(res)

dimnames(res)
dimnames(res)[[1]]
dimnames(res)[[2]]
```

```{r}

# "gert" package installed on in user dir
(res  <- x[x[, "Package"] == "gert", , drop=F ])



```{r}
(res  <- x[x[, "Package"] == "class", , drop=F ])

## from these 2 rows, choose is sys
(res2  <- res[res[, "LibPath"] == .libPaths()[[2]], , drop=F])

## this is the row  to upgrade !   user
(res2  <- res[res[, "LibPath"] == .libPaths()[[1]], , drop=F])

# about 29, standard packages  in sys

(res  <- x[x[, "LibPath"] == .libPaths()[[2]], c("Package", "LibPath"), drop=F])

```








